
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>repository: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/shion0625/FYP/backend/pkg/repository/auth.go (85.7%)</option>
				
				<option value="file1">github.com/shion0625/FYP/backend/pkg/repository/order.go (0.0%)</option>
				
				<option value="file2">github.com/shion0625/FYP/backend/pkg/repository/product.go (0.0%)</option>
				
				<option value="file3">github.com/shion0625/FYP/backend/pkg/repository/user.go (0.0%)</option>
				
				<option value="file4">github.com/shion0625/FYP/backend/pkg/usecase/auth.go (0.0%)</option>
				
				<option value="file5">github.com/shion0625/FYP/backend/pkg/usecase/order.go (100.0%)</option>
				
				<option value="file6">github.com/shion0625/FYP/backend/pkg/usecase/product.go (91.2%)</option>
				
				<option value="file7">github.com/shion0625/FYP/backend/pkg/usecase/user.go (0.0%)</option>
				
				<option value="file8">github.com/shion0625/FYP/backend/pkg/utils/compare.go (100.0%)</option>
				
				<option value="file9">github.com/shion0625/FYP/backend/pkg/utils/credit_card.go (83.3%)</option>
				
				<option value="file10">github.com/shion0625/FYP/backend/pkg/utils/errors.go (100.0%)</option>
				
				<option value="file11">github.com/shion0625/FYP/backend/pkg/utils/get_param_id.go (100.0%)</option>
				
				<option value="file12">github.com/shion0625/FYP/backend/pkg/utils/helper.go (100.0%)</option>
				
				<option value="file13">github.com/shion0625/FYP/backend/pkg/utils/hsash.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package repository

import (
        "github.com/labstack/echo/v4"
        "github.com/shion0625/FYP/backend/pkg/domain"
        "github.com/shion0625/FYP/backend/pkg/repository/interfaces"
        "gorm.io/gorm"
)

type authDatabase struct {
        DB *gorm.DB
}

func NewAuthRepository(db *gorm.DB) interfaces.AuthRepository <span class="cov8" title="1">{
        return &amp;authDatabase{
                DB: db,
        }
}</span>

func (c *authDatabase) SaveRefreshSession(ctx echo.Context, refreshSession domain.RefreshSession) error <span class="cov8" title="1">{
        if err := c.DB.Table("refresh_sessions").Create(&amp;refreshSession).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *authDatabase) FindRefreshSessionByTokenID(ctx echo.Context, tokenID string) (refreshSession domain.RefreshSession, err error) <span class="cov8" title="1">{
        if err := c.DB.Table("refresh_sessions").Where("token_id = ?", tokenID).First(&amp;refreshSession).Error; err != nil </span><span class="cov8" title="1">{
                return refreshSession, err
        }</span>

        <span class="cov8" title="1">return refreshSession, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package repository

import (
        "fmt"
        "strconv"
        "time"

        "github.com/labstack/echo/v4"
        "github.com/shion0625/FYP/backend/pkg/api/handler/request"
        "github.com/shion0625/FYP/backend/pkg/api/handler/response"
        "github.com/shion0625/FYP/backend/pkg/domain"
        "github.com/shion0625/FYP/backend/pkg/repository/interfaces"
        "gorm.io/gorm"
)

type orderDatabase struct {
        DB *gorm.DB
}

func NewOrderRepository(db *gorm.DB) interfaces.OrderRepository <span class="cov0" title="0">{
        return &amp;orderDatabase{
                DB: db,
        }
}</span>

func (c *orderDatabase) Transactions(ctx echo.Context, trxFn func(repo interfaces.OrderRepository) error) error <span class="cov0" title="0">{
        trx := c.DB.Begin()

        repo := NewOrderRepository(trx)

        if err := trxFn(repo); err != nil </span><span class="cov0" title="0">{
                trx.Rollback()

                return err
        }</span>

        <span class="cov0" title="0">if err := trx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                trx.Rollback()

                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *orderDatabase) UpdateProductItemStock(ctx echo.Context, productItemID uint, purchaseQuantity uint) (newStock uint, err error) <span class="cov0" title="0">{
        var productItem domain.ProductItem
        err = c.DB.Table("product_items").Select("qty_in_stock").Where("id = ?", productItemID).First(&amp;productItem).Error

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if productItem.QtyInStock &lt; purchaseQuantity </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("%s not enough stock", productItem.Name)
        }</span>

        <span class="cov0" title="0">newStock = productItem.QtyInStock - purchaseQuantity
        err = c.DB.Table("product_items").Where("id = ?", productItem.ID).Update("qty_in_stock", newStock).Error

        return newStock, err</span>
}

func (c *orderDatabase) SaveOrder(ctx echo.Context, userID string, payOrder request.PayOrder) error <span class="cov0" title="0">{
        // Create a new ShopOrder from the PayOrder request
        shopOrder := domain.ShopOrder{
                UserID:          userID,
                OrderDate:       time.Now(),
                OrderTotalPrice: payOrder.TotalFee,
                AddressID:       payOrder.AddressID,
                PaymentMethodID: payOrder.PaymentMethodID,
        }

        // Save the ShopOrder to the database
        if err := c.DB.Create(&amp;shopOrder).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">shopOrderProductItems := make([]domain.ShopOrderProductItem, 0, len(payOrder.ProductItemInfo))

        for _, productItemInfo := range payOrder.ProductItemInfo </span><span class="cov0" title="0">{
                shopOrderProductItem := domain.ShopOrderProductItem{
                        ShopOrderID:   shopOrder.ID,
                        ProductItemID: productItemInfo.ProductItemID,
                        Count:         productItemInfo.Count,
                }
                shopOrderProductItems = append(shopOrderProductItems, shopOrderProductItem)

                shopOrderVariations := make([]domain.ShopOrderVariation, 0, len(*productItemInfo.VariationValues))

                for _, variationValue := range *productItemInfo.VariationValues </span><span class="cov0" title="0">{
                        shopOrderVariation := domain.ShopOrderVariation{
                                ShopOrderID:       shopOrder.ID,
                                ProductItemID:     productItemInfo.ProductItemID,
                                VariationID:       variationValue.VariationID,
                                VariationOptionID: variationValue.VariationOptionID,
                        }
                        shopOrderVariations = append(shopOrderVariations, shopOrderVariation)
                }</span>

                <span class="cov0" title="0">if err := c.DB.Create(&amp;shopOrderVariations).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := c.DB.Create(&amp;shopOrderProductItems).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *orderDatabase) PayOrder(ctx echo.Context, paymentMethodID uint) error <span class="cov0" title="0">{
        paymentMethod := domain.PaymentMethod{
                ID: paymentMethodID,
        }

        if err := c.DB.First(&amp;paymentMethod).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (o *orderDatabase) GetShopOrders(ctx echo.Context, userID string, pagination request.Pagination) (orders []response.Order, err error) <span class="cov0" title="0">{
        limit := pagination.Count
        offset := (pagination.PageNumber - 1) * limit

        var shopOrders []domain.ShopOrder
        if err := o.DB.Preload("Address").Preload("PaymentMethod").Table("shop_orders").Limit(int(limit)).Offset(int(offset)).Where("user_id= ?", userID).Find(&amp;shopOrders).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">fmt.Print(&amp;shopOrders)

        for _, shopOrder := range shopOrders </span><span class="cov0" title="0">{
                var productItemInfos []response.ProductItemInfo

                var shopOrderProductItems []domain.ShopOrderProductItem
                if err := o.DB.Where("shop_order_id = ?", shopOrder.ID).Find(&amp;shopOrderProductItems).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">for _, productItem := range shopOrderProductItems </span><span class="cov0" title="0">{
                        var variationValues []response.VariationValues

                        var shopOrderVariations []domain.ShopOrderVariation
                        if err := o.DB.Where("shop_order_id = ? AND product_item_id = ?", shopOrder.ID, productItem.ProductItemID).Find(&amp;shopOrderVariations).Error; err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">for _, variation := range shopOrderVariations </span><span class="cov0" title="0">{
                                variationValues = append(variationValues, response.VariationValues{
                                        VariationID:       variation.VariationID,
                                        Name:              variation.Variation.Name,
                                        VariationOptionID: variation.VariationOptionID,
                                        Value:             variation.VariationOption.Value,
                                })
                        }</span>

                        <span class="cov0" title="0">productItemInfos = append(productItemInfos, response.ProductItemInfo{
                                ProductItemID:   productItem.ProductItemID,
                                Count:           productItem.Count,
                                VariationValues: &amp;variationValues,
                        })</span>
                }

                <span class="cov0" title="0">orders = append(orders, response.Order{
                        UserID:          shopOrder.UserID,
                        ShopOrderId:     strconv.Itoa(int(shopOrder.ID)),
                        ProductItemInfo: productItemInfos,
                        Address: response.Address{
                                ID:   shopOrder.Address.ID,
                                Name: shopOrder.Address.Name,
                        },
                        TotalFee: shopOrder.OrderTotalPrice,
                        PaymentMethod: response.PaymentMethod{
                                ID:     shopOrder.PaymentMethod.ID,
                                Number: shopOrder.PaymentMethod.Number,
                        },
                })</span>
        }

        //nolint:nakedret
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package repository

import (
        "context"
        "time"

        "github.com/labstack/echo/v4"
        "github.com/shion0625/FYP/backend/pkg/api/handler/request"
        "github.com/shion0625/FYP/backend/pkg/api/handler/response"
        "github.com/shion0625/FYP/backend/pkg/domain"
        "github.com/shion0625/FYP/backend/pkg/repository/interfaces"
        "gorm.io/gorm"
)

type productDatabase struct {
        DB *gorm.DB
}

func NewProductRepository(db *gorm.DB) interfaces.ProductRepository <span class="cov0" title="0">{
        return &amp;productDatabase{
                DB: db,
        }
}</span>

func (c *productDatabase) Transactions(ctx echo.Context, trxFn func(repo interfaces.ProductRepository) error) error <span class="cov0" title="0">{
        trx := c.DB.Begin()

        repo := NewProductRepository(trx)

        if err := trxFn(repo); err != nil </span><span class="cov0" title="0">{
                trx.Rollback()

                return err
        }</span>

        <span class="cov0" title="0">if err := trx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                trx.Rollback()

                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// To check the category name exist.
func (c *productDatabase) IsCategoryNameExist(ctx echo.Context, name string) (exist bool, err error) <span class="cov0" title="0">{
        err = c.DB.Table("categories").Where("name = ? AND category_id IS NULL", name).First(&amp;exist).Error

        return
}</span>

// Save Category.
func (c *productDatabase) SaveCategory(ctx echo.Context, categoryName string) (err error) <span class="cov0" title="0">{
        err = c.DB.Table("categories").Create(&amp;domain.Category{Name: categoryName}).Error

        return err
}</span>

// Find all main category(its not have a category_id).
func (c *productDatabase) FindAllMainCategories(ctx echo.Context,
        pagination request.Pagination,
) (categories []response.Category, err error) <span class="cov0" title="0">{
        limit := pagination.Count
        offset := (pagination.PageNumber - 1) * limit

        err = c.DB.Table("categories").Limit(int(limit)).Offset(int(offset)).Find(&amp;categories).Error

        return
}</span>

// Find all variations which related to given category id.
func (c *productDatabase) FindAllVariationsByCategoryID(ctx echo.Context,
        categoryID uint,
) (variations []response.Variation, err error) <span class="cov0" title="0">{
        err = c.DB.Table("variations").Where("category_id = ?", categoryID).Find(&amp;variations).Error

        return
}</span>

// Find all variation options which related to given variation id.
func (c productDatabase) FindAllVariationOptionsByVariationID(ctx echo.Context,
        variationID uint,
) (variationOptions []response.VariationOption, err error) <span class="cov0" title="0">{
        err = c.DB.Table("variation_options").Where("variation_id = ?", variationID).Find(&amp;variationOptions).Error

        return
}</span>

// To check a variation exist for the given category.
func (c *productDatabase) IsVariationNameExistForCategory(ctx echo.Context,
        name string, categoryID uint,
) (exist bool, err error) <span class="cov0" title="0">{
        err = c.DB.Table("variations").Where("name = ? AND category_id = ?", name, categoryID).First(&amp;exist).Error

        return
}</span>

// To check a variation value exist for the given variation.
func (c *productDatabase) IsVariationValueExistForVariation(ctx echo.Context,
        value string, variationID uint,
) (exist bool, err error) <span class="cov0" title="0">{
        err = c.DB.Table("variation_options").Where("value = ? AND variation_id = ?", value, variationID).First(&amp;exist).Error

        return
}</span>

// Save Variation for category.
func (c *productDatabase) SaveVariation(ctx echo.Context, categoryID uint, variationName string) error <span class="cov0" title="0">{
        err := c.DB.Table("variations").Create(&amp;domain.Variation{CategoryID: categoryID, Name: variationName}).Error

        return err
}</span>

// add variation option.
func (c *productDatabase) SaveVariationOption(ctx echo.Context, variationID uint, variationValue string) error <span class="cov0" title="0">{
        err := c.DB.Table("variation_options").Create(&amp;domain.VariationOption{VariationID: variationID, Value: variationValue}).Error

        return err
}</span>

// find product by id.
func (c *productDatabase) FindProductByID(ctx echo.Context, productID uint) (product response.Product, err error) <span class="cov0" title="0">{
        err = c.DB.Table("products").Where("id = ?", productID).Find(&amp;product).Error

        return
}</span>

func (c *productDatabase) IsProductNameExistForOtherProduct(ctx echo.Context,
        name string, productID uint,
) (exist bool, err error) <span class="cov0" title="0">{
        err = c.DB.Table("products").Where("name = ? AND id != ?", name, productID).First(&amp;exist).Error

        return
}</span>

func (c *productDatabase) IsProductNameExist(ctx echo.Context, productName string) (exist bool, err error) <span class="cov0" title="0">{
        err = c.DB.Table("products").Where("name = ?", productName).First(&amp;exist).Error

        return
}</span>

// to add a new product in database.
func (c *productDatabase) SaveProduct(ctx echo.Context, product domain.Product) error <span class="cov0" title="0">{
        product.CreatedAt = time.Now()
        err := c.DB.Table("products").Create(&amp;product).Error

        return err
}</span>

// update product.
func (c *productDatabase) UpdateProduct(ctx echo.Context, product domain.Product) error <span class="cov0" title="0">{
        product.UpdatedAt = time.Now()

        err := c.DB.Table("products").Where("id = ?", product.ID).Updates(&amp;product).Error

        return err
}</span>

// get all products from database.
func (c *productDatabase) FindAllProducts(ctx echo.Context, pagination request.Pagination, categoryID *uint, brandID *uint) (products []response.Product, err error) <span class="cov0" title="0">{
        limit := int(pagination.Count)
        offset := (int(pagination.PageNumber) - 1) * limit

        db := c.DB.Table("products p").
                Select("p.id, p.name, p.description, p.price, p.discount_price, p.image, p.category_id, sc.name AS category_name, p.brand_id, b.name AS brand_name, p.created_at, p.updated_at").
                Joins("INNER JOIN categories sc ON p.category_id = sc.id").
                Joins("INNER JOIN brands b ON b.id = p.brand_id").
                Order("created_at DESC").
                Limit(limit).
                Offset(offset)

        if categoryID != nil </span><span class="cov0" title="0">{
                db = db.Where("p.category_id = ?", *categoryID)
        }</span>

        <span class="cov0" title="0">if brandID != nil </span><span class="cov0" title="0">{
                db = db.Where("p.brand_id = ?", *brandID)
        }</span>

        <span class="cov0" title="0">err = db.Scan(&amp;products).Error

        return</span>
}

// to get productItem id.
func (c *productDatabase) FindProductItemByID(ctx echo.Context, productItemID uint) (productItem domain.ProductItem, err error) <span class="cov0" title="0">{
        err = c.DB.Table("product_items").Where("id = ?", productItemID).Find(&amp;productItem).Error

        return productItem, err
}</span>

// to get how many variations are available for a product.
func (c *productDatabase) FindVariationCountForProduct(ctx echo.Context, productID uint) (variationCount uint, err error) <span class="cov0" title="0">{
        var count int64
        err = c.DB.Table("variations v").
                Joins("INNER JOIN categories c ON c.id = v.category_id").
                Joins("INNER JOIN products p ON p.category_id = v.category_id").
                Where("p.id = ?", productID).Count(&amp;count).Error
        variationCount = uint(count)

        return
}</span>

// To find all product item ids which related to the given product id and variation option id.
func (c *productDatabase) FindAllProductItemIDsByProductIDAndVariationOptionID(ctx context.Context, productID,
        variationOptionID uint,
) (productItemIDs []uint, err error) <span class="cov0" title="0">{
        err = c.DB.Table("product_items pi").
                Joins("INNER JOIN product_configurations pc ON pi.id = pc.product_item_id").
                Where("pi.product_id = ? AND variation_option_id = ?", productID, variationOptionID).Find(&amp;productItemIDs).Error

        return
}</span>

func (c *productDatabase) SaveProductConfiguration(ctx echo.Context, productItemID, variationOptionID uint) error <span class="cov0" title="0">{
        err := c.DB.Table("product_configurations").Create(&amp;domain.ProductConfiguration{ProductItemID: productItemID, VariationOptionID: variationOptionID}).Error

        return err
}</span>

func (c *productDatabase) SaveProductItem(ctx echo.Context, productItem domain.ProductItem) (productItemID uint, err error) <span class="cov0" title="0">{
        productItem.CreatedAt = time.Now()
        err = c.DB.Table("product_items").Create(&amp;productItem).Scan(&amp;productItemID).Error

        return
}</span>

// for get all products items for a product.
func (c *productDatabase) FindAllProductItems(ctx echo.Context,
        productID uint,
) (productItems []response.ProductItemsDB, err error) <span class="cov0" title="0">{
        // first find all product_items
        err = c.DB.Table("product_items pi").
                Select("p.name, pi.id,  pi.product_id,pi.name AS item_name, pi.price, pi.discount_price, pi.qty_in_stock, pi.sku, p.category_id, sc.name AS category_name, p.brand_id, b.name AS brand_name").
                Joins("INNER JOIN products p ON p.id = pi.product_id").
                Joins("INNER JOIN categories sc ON p.category_id = sc.id").
                Joins("INNER JOIN brands b ON b.id = p.brand_id").
                Where("pi.product_id = ?", productID).Find(&amp;productItems).Error

        return
}</span>

// Find all variation and value of a product item.
func (c *productDatabase) FindAllVariationValuesOfProductItem(ctx echo.Context,
        productItemID uint,
) (productVariationsValues []response.ProductVariationValue, err error) <span class="cov0" title="0">{
        err = c.DB.Table("product_configurations pc").
                Select("v.id AS variation_id, v.name, vo.id AS variation_option_id, vo.value").
                Joins("INNER JOIN variation_options vo ON vo.id = pc.variation_option_id").
                Joins("INNER JOIN variations v ON v.id = vo.variation_id").
                Where("pc.product_item_id = ?", productItemID).Find(&amp;productVariationsValues).Error

        return
}</span>

// To save image for product item.
func (c *productDatabase) SaveProductItemImage(ctx echo.Context, productItemID uint, image string) error <span class="cov0" title="0">{
        err := c.DB.Table("product_images").Create(&amp;domain.ProductImage{ProductItemID: productItemID, Image: image}).Error

        return err
}</span>

// To find all images of a product item.
func (c *productDatabase) FindAllProductItemImages(ctx echo.Context, productItemID uint) (images []string, err error) <span class="cov0" title="0">{
        err = c.DB.Table("product_images").Select("image").Where("product_item_id = ?", productItemID).Find(&amp;images).Error

        return
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package repository

import (
        "errors"
        "fmt"
        "time"

        "github.com/labstack/echo/v4"
        "github.com/shion0625/FYP/backend/pkg/api/handler/response"
        "github.com/shion0625/FYP/backend/pkg/domain"
        "github.com/shion0625/FYP/backend/pkg/repository/interfaces"
        "gorm.io/gorm"
)

type result struct {
        Exist string `gorm:"column:exist"`
}

type userDatabase struct {
        DB *gorm.DB
}

func NewUserRepository(db *gorm.DB) interfaces.UserRepository <span class="cov0" title="0">{
        return &amp;userDatabase{DB: db}
}</span>

func (c *userDatabase) FindUserByUserID(ctx echo.Context, userID string) (user domain.User, err error) <span class="cov0" title="0">{
        err = c.DB.Where("id = ?", userID).First(&amp;user).Error

        return user, err
}</span>

func (c *userDatabase) FindUserByUserName(ctx echo.Context, userName string) (user domain.User, err error) <span class="cov0" title="0">{
        err = c.DB.Where("user_name = ?", userName).First(&amp;user).Error

        return user, err
}</span>

func (c *userDatabase) FindUserByEmail(ctx echo.Context, email string) (user domain.User, err error) <span class="cov0" title="0">{
        err = c.DB.Where("email = ?", email).First(&amp;user).Error

        return user, err
}</span>

func (c *userDatabase) FindUserByPhoneNumber(ctx echo.Context, phoneNumber string) (user domain.User, err error) <span class="cov0" title="0">{
        err = c.DB.Where("phone = ?", phoneNumber).First(&amp;user).Error

        return user, err
}</span>

func (c *userDatabase) FindUserByUserNameEmailOrPhone(ctx echo.Context,
        userDetails domain.User,
) (user domain.User, err error) <span class="cov0" title="0">{
        err = c.DB.Where("user_name = ? OR email = ? OR phone = ?",
                userDetails.UserName, userDetails.Email, userDetails.Phone).Find(&amp;user).Error

        return user, err
}</span>

func (c *userDatabase) SaveUser(ctx echo.Context, user domain.User) (userID string, err error) <span class="cov0" title="0">{
        // save the user details
        user = domain.User{
                Age:         user.Age,
                GoogleImage: user.GoogleImage,
                FirstName:   user.FirstName,
                LastName:    user.LastName,
                UserName:    user.UserName,
                Email:       user.Email,
                Phone:       user.Phone,
                Password:    user.Password,
                CreatedAt:   time.Now(),
        }
        result := c.DB.Create(&amp;user)

        return user.ID, result.Error
}</span>

func (c *userDatabase) FindAllAddressByUserID(ctx echo.Context, userID string) (addresses []response.Address, err error) <span class="cov0" title="0">{
        err = c.DB.
                Table("user_addresses").
                Select("addresses.id, addresses.house, addresses.name, addresses.phone_number, addresses.area, addresses.land_mark, addresses.city, addresses.pincode, addresses.country_name, user_addresses.is_default").
                Joins("JOIN addresses ON user_addresses.address_id = addresses.id").
                Where("user_addresses.user_id = ?", userID).
                Scan(&amp;addresses).Error

        return addresses, err
}</span>

func (c *userDatabase) FindAddressByUserIDAndAddressID(ctx echo.Context, userID string, addressID uint) (address domain.Address, err error) <span class="cov0" title="0">{
        err = c.DB.
                Table("user_addresses").
                Select("addresses.id, addresses.house, addresses.name, addresses.phone_number, addresses.area, addresses.land_mark, addresses.city, addresses.pincode, addresses.country_name, user_addresses.is_default").
                Joins("JOIN addresses ON user_addresses.address_id = addresses.id").
                Where("user_addresses.user_id = ? AND addresses.id = ?", userID, addressID).
                Scan(&amp;address).Error

        return address, err
}</span>

func (c *userDatabase) IsAddressAlreadyExistForUser(ctx echo.Context, address domain.Address, userID string) (exist bool, err error) <span class="cov0" title="0">{
        var addressRes domain.Address
        err = c.DB.Table("user_addresses").
                Select("addresses.id").
                Joins("INNER JOIN addresses ON user_addresses.address_id = addresses.id").
                Where("addresses.name = ? AND addresses.house = ? AND addresses.land_mark = ? AND addresses.pincode = ? AND user_addresses.user_id = ?", address.Name, address.House, address.LandMark, address.Pincode, userID).
                First(&amp;addressRes).Error

        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, err</span>
}

func (c *userDatabase) IsAddressIDExist(ctx echo.Context, addressID uint) (exist bool, err error) <span class="cov0" title="0">{
        var addressModel domain.Address
        err = c.DB.Table("addresses").
                Select("addresses.id").
                Where("id = ?", addressID).
                First(&amp;addressModel).Error

        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, err</span>
}

func (c *userDatabase) SaveAddress(ctx echo.Context, address domain.Address) (addressID uint, err error) <span class="cov0" title="0">{
        address.CreatedAt = time.Now()
        result := c.DB.Create(&amp;address)

        if result.Error != nil </span><span class="cov0" title="0">{
                return addressID, errors.New("failed to insert address on database")
        }</span>

        <span class="cov0" title="0">return address.ID, nil</span>
}

func (c *userDatabase) SaveUserAddress(ctx echo.Context, userAddress domain.UserAddress) error <span class="cov0" title="0">{
        // first check user's first address is this or not
        var userID uint
        if err := c.DB.Table("user_addresses").Select("address_id").Where("user_id = ?", userAddress.UserID).Scan(&amp;userID).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if user already has an address with user_id %v", userAddress.UserID)
        }</span>

        // if the given address needs to be set as default, then remove all others from default
        <span class="cov0" title="0">if userID == 0 </span><span class="cov0" title="0">{ // it means user has no other addresses
                userAddress.IsDefault = true
        }</span> else<span class="cov0" title="0"> if userAddress.IsDefault </span><span class="cov0" title="0">{
                query := `UPDATE user_addresses SET is_default = 'f' WHERE user_id = ?`
                if c.DB.Exec(query, userAddress.UserID).Scan(&amp;userAddress).Error != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to remove default status of address")
                }</span>
        }

        // insert the user address
        <span class="cov0" title="0">if err := c.DB.Table("user_addresses").Create(&amp;userAddress).Error; err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to insert userAddress into database")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *userDatabase) UpdateAddress(ctx echo.Context, address domain.Address) error <span class="cov0" title="0">{
        if err := c.DB.Model(&amp;address).Where("id = ?", address.ID).Updates(map[string]interface{}{
                "name":         address.Name,
                "phone_number": address.PhoneNumber,
                "house":        address.House,
                "area":         address.Area,
                "land_mark":    address.LandMark,
                "city":         address.City,
                "pincode":      address.Pincode,
                "country_name": address.CountryName,
                "updated_at":   time.Now(),
        }).Error; err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to update the address for edit address")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *userDatabase) UpdateUser(ctx echo.Context, user domain.User) (err error) <span class="cov0" title="0">{
        updatedAt := time.Now()
        // check password need to update or not
        if user.Password != "" </span><span class="cov0" title="0">{
                err = c.DB.Model(&amp;user).Where("id = ?", user.ID).Updates(map[string]interface{}{
                        "user_name":  user.UserName,
                        "first_name": user.FirstName,
                        "last_name":  user.LastName,
                        "age":        user.Age,
                        "email":      user.Email,
                        "phone":      user.Phone,
                        "password":   user.Password,
                        "updated_at": updatedAt,
                }).Error
        }</span> else<span class="cov0" title="0"> {
                err = c.DB.Model(&amp;user).Where("id = ?", user.ID).Updates(map[string]interface{}{
                        "user_name":  user.UserName,
                        "first_name": user.FirstName,
                        "last_name":  user.LastName,
                        "age":        user.Age,
                        "email":      user.Email,
                        "phone":      user.Phone,
                        "updated_at": updatedAt,
                }).Error
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user detail of user with user_id %s", user.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *userDatabase) UpdateUserAddress(ctx echo.Context, userAddress domain.UserAddress) error <span class="cov0" title="0">{
        // if it needs to be set as default, then change the old default
        if userAddress.IsDefault </span><span class="cov0" title="0">{
                if err := c.DB.Model(&amp;domain.UserAddress{}).Where("user_id = ?", userAddress.UserID).Update("is_default", false).Error; err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to remove default status of address")
                }</span>
        }

        // update the user address
        <span class="cov0" title="0">if err := c.DB.Model(&amp;userAddress).Where("address_id = ? AND user_id = ?", userAddress.AddressID, userAddress.UserID).Update("is_default", userAddress.IsDefault).Error; err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to update user address")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *userDatabase) FindAllPaymentMethodsByUserID(ctx echo.Context, userID string) (paymentMethods []response.PaymentMethod, err error) <span class="cov0" title="0">{
        err = c.DB.
                Table("payment_methods").
                Select("id, number", "card_company").
                Where("user_id = ?", userID).
                Scan(&amp;paymentMethods).Error

        return paymentMethods, err
}</span>

func (c *userDatabase) SavePaymentMethod(ctx echo.Context, paymentMethod domain.PaymentMethod) (paymentMethodID uint, err error) <span class="cov0" title="0">{
        paymentMethod.CreatedAt = time.Now()
        result := c.DB.Create(&amp;paymentMethod)

        if result.Error != nil </span><span class="cov0" title="0">{
                return paymentMethodID, errors.New("failed to insert address on database")
        }</span>

        <span class="cov0" title="0">return paymentMethod.ID, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package usecase

import (
        "fmt"
        "log"
        "time"

        "github.com/labstack/echo/v4"
        "github.com/shion0625/FYP/backend/pkg/api/handler/request"
        "github.com/shion0625/FYP/backend/pkg/domain"
        repoInterfaces "github.com/shion0625/FYP/backend/pkg/repository/interfaces"
        "github.com/shion0625/FYP/backend/pkg/service/token"
        "github.com/shion0625/FYP/backend/pkg/usecase/interfaces"
        "github.com/shion0625/FYP/backend/pkg/utils"
)

const (
        countryCode       = "+91"
        otpExpireDuration = time.Minute * 2
)

const (
        AccessTokenDuration  = time.Minute * 25   // 25Minutes
        RefreshTokenDuration = time.Hour*24*7 + 1 //  7 days+ 1hour
)

type authUseCase struct {
        userRepo     repoInterfaces.UserRepository
        tokenService token.TokenService
        authRepo     repoInterfaces.AuthRepository
}

func NewAuthUseCase(
        userRepo repoInterfaces.UserRepository,
        tokenService token.TokenService,
        authRepo repoInterfaces.AuthRepository,
) interfaces.AuthUseCase <span class="cov0" title="0">{
        return &amp;authUseCase{
                userRepo:     userRepo,
                tokenService: tokenService,
                authRepo:     authRepo,
        }
}</span>

func (a *authUseCase) UserLogin(ctx echo.Context, loginInfo request.Login) (string, error) <span class="cov0" title="0">{
        var (
                user domain.User
                err  error
        )

        switch </span>{
        case loginInfo.Email != "":<span class="cov0" title="0">
                user, err = a.userRepo.FindUserByEmail(ctx, loginInfo.Email)</span>
        case loginInfo.UserName != "":<span class="cov0" title="0">
                user, err = a.userRepo.FindUserByUserName(ctx, loginInfo.UserName)</span>
        case loginInfo.Phone != "":<span class="cov0" title="0">
                user, err = a.userRepo.FindUserByPhoneNumber(ctx, loginInfo.Phone)</span>
        default:<span class="cov0" title="0">
                return "", ErrEmptyLoginCredentials</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to find user from database: %w", err)
        }</span>

        <span class="cov0" title="0">if user.ID == "" </span><span class="cov0" title="0">{
                return "", ErrUserNotExist
        }</span>

        <span class="cov0" title="0">if user.BlockStatus </span><span class="cov0" title="0">{
                return "", ErrUserBlocked
        }</span>

        // // otp verified
        // if !user.Verified {
        //         return "", ErrUserNotVerified
        // }

        <span class="cov0" title="0">if err := utils.ComparePasswordWithHashedPassword(loginInfo.Password, user.Password); err != nil </span><span class="cov0" title="0">{
                return "", ErrWrongPassword
        }</span>

        <span class="cov0" title="0">return user.ID, nil</span>
}

func (a *authUseCase) UserSignUp(ctx echo.Context, signUpDetails domain.User) (string, error) <span class="cov0" title="0">{
        existUser, err := a.userRepo.FindUserByUserNameEmailOrPhone(ctx, signUpDetails)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to check user %w", err)
        }</span>

        <span class="cov0" title="0">if existUser != (domain.User{}) </span><span class="cov0" title="0">{
                // 一致しているプロパティをエラー内容として返す
                errorMsg := "failed to check user details already exist:"
                if signUpDetails.UserName == existUser.UserName </span><span class="cov0" title="0">{
                        errorMsg += "\rUserName already exists"
                }</span>

                <span class="cov0" title="0">if signUpDetails.Email == existUser.Email </span><span class="cov0" title="0">{
                        errorMsg += "\rEmail already exists"
                }</span>

                <span class="cov0" title="0">if signUpDetails.Phone == existUser.Phone </span><span class="cov0" title="0">{
                        errorMsg += "\rPhone already exists"
                }</span>

                <span class="cov0" title="0">return "", fmt.Errorf("%s.", errorMsg)</span>
        }

        // // if user credentials already exist and  verified then return it as errors
        // if existUser.ID != "" &amp;&amp; existUser.Verified {
        //         err = utils.CompareUserExistingDetails(existUser, signUpDetails)

        //         return "", fmt.Errorf("failed to user is not otp verified: %w", err)
        // }

        <span class="cov0" title="0">userID := existUser.ID

        if userID == "" </span><span class="cov0" title="0">{ // if user not exist then save user on database
                hashPass, err := utils.GenerateHashFromPassword(signUpDetails.Password)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to hash the password: %w", err)
                }</span>

                <span class="cov0" title="0">signUpDetails.Password = hashPass
                _, err = a.userRepo.SaveUser(ctx, signUpDetails)

                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to save user details: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return "success", nil</span>
}

func (a *authUseCase) GenerateAccessToken(ctx echo.Context, tokenParams interfaces.GenerateTokenParams) (string, error) <span class="cov0" title="0">{
        tokenReq := token.GenerateTokenRequest{
                UserID:   tokenParams.UserID,
                UsedFor:  tokenParams.UserType,
                ExpireAt: time.Now().Add(AccessTokenDuration),
        }

        tokenRes, err := a.tokenService.GenerateToken(tokenReq)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate access token: %w", err)
        }</span>

        <span class="cov0" title="0">return tokenRes.TokenString, nil</span>
}

func (a *authUseCase) GenerateRefreshToken(ctx echo.Context, tokenParams interfaces.GenerateTokenParams) (string, error) <span class="cov0" title="0">{
        expireAt := time.Now().Add(RefreshTokenDuration)
        tokenReq := token.GenerateTokenRequest{
                UserID:   tokenParams.UserID,
                UsedFor:  tokenParams.UserType,
                ExpireAt: expireAt,
        }

        tokenRes, err := a.tokenService.GenerateToken(tokenReq)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        <span class="cov0" title="0">err = a.authRepo.SaveRefreshSession(ctx, domain.RefreshSession{
                UserID:       tokenParams.UserID,
                TokenID:      tokenRes.TokenID,
                RefreshToken: tokenRes.TokenString,
                ExpireAt:     expireAt,
        })

        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to save refresh session: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("successfully refresh token created and refresh session stored in database")

        return tokenRes.TokenString, nil</span>
}

func (c *authUseCase) VerifyAndGetRefreshTokenSession(ctx echo.Context, refreshToken string, usedFor token.UserType) (domain.RefreshSession, error) <span class="cov0" title="0">{
        verifyReq := token.VerifyTokenRequest{
                TokenString: refreshToken,
                UsedFor:     usedFor,
        }

        verifyRes, err := c.tokenService.VerifyToken(verifyReq)
        if err != nil </span><span class="cov0" title="0">{
                return domain.RefreshSession{}, fmt.Errorf("failed to save refresh session: %w", err)
        }</span>

        <span class="cov0" title="0">refreshSession, err := c.authRepo.FindRefreshSessionByTokenID(ctx, verifyRes.TokenID)
        if err != nil </span><span class="cov0" title="0">{
                return refreshSession, fmt.Errorf("failed to find refresh session by token ID: %w", err)
        }</span>

        <span class="cov0" title="0">if refreshSession.TokenID == "" </span><span class="cov0" title="0">{
                return refreshSession, ErrRefreshSessionNotExist
        }</span>

        <span class="cov0" title="0">if time.Since(refreshSession.ExpireAt) &gt; 0 </span><span class="cov0" title="0">{
                return domain.RefreshSession{}, ErrRefreshSessionExpired
        }</span>

        <span class="cov0" title="0">if refreshSession.IsBlocked </span><span class="cov0" title="0">{
                return domain.RefreshSession{}, ErrRefreshSessionBlocked
        }</span>

        <span class="cov0" title="0">return refreshSession, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package usecase

import (
        "fmt"

        "github.com/labstack/echo/v4"
        "github.com/shion0625/FYP/backend/pkg/api/handler/request"
        "github.com/shion0625/FYP/backend/pkg/api/handler/response"
        repoInterfaces "github.com/shion0625/FYP/backend/pkg/repository/interfaces"
        "github.com/shion0625/FYP/backend/pkg/usecase/interfaces"
)

type orderUseCase struct {
        orderRepo repoInterfaces.OrderRepository
}

func NewOrderUseCase(
        orderRepo repoInterfaces.OrderRepository,
) interfaces.OrderUseCase <span class="cov8" title="1">{
        return &amp;orderUseCase{
                orderRepo: orderRepo,
        }
}</span>

func (o *orderUseCase) PayOrder(ctx echo.Context, userID string, payOrder request.PayOrder) error <span class="cov8" title="1">{
        if err := o.orderRepo.Transactions(ctx, o.updateStockAndPayOrder(ctx, userID, payOrder)); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to pay order: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *orderUseCase) updateStockAndPayOrder(ctx echo.Context, userID string, payOrder request.PayOrder) func(repo repoInterfaces.OrderRepository) error <span class="cov8" title="1">{
        return func(repo repoInterfaces.OrderRepository) error </span><span class="cov8" title="1">{
                for _, itemInfo := range payOrder.ProductItemInfo </span><span class="cov8" title="1">{
                        newStock, err := repo.UpdateProductItemStock(ctx, itemInfo.ProductItemID, itemInfo.Count)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to update productItem stock to %d: %w", newStock, err)
                        }</span>
                }

                <span class="cov8" title="1">if err := repo.PayOrder(ctx, payOrder.PaymentMethodID); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w", err)
                }</span>

                <span class="cov8" title="1">if err := repo.SaveOrder(ctx, userID, payOrder); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }
}

func (o *orderUseCase) GetAllShopOrders(ctx echo.Context, userID string, pagination request.Pagination) (orderHistory []response.Order, err error) <span class="cov8" title="1">{
        orderHistory, err = o.orderRepo.GetShopOrders(ctx, userID, pagination)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to find addresses: %w", err)
        }</span>

        <span class="cov8" title="1">return orderHistory, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package usecase

import (
        "context"
        "fmt"

        "github.com/labstack/echo/v4"
        "github.com/shion0625/FYP/backend/pkg/api/handler/request"
        "github.com/shion0625/FYP/backend/pkg/api/handler/response"
        "github.com/shion0625/FYP/backend/pkg/domain"
        "github.com/shion0625/FYP/backend/pkg/repository/interfaces"
        "github.com/shion0625/FYP/backend/pkg/service/cloud"
        usecaseInterfaces "github.com/shion0625/FYP/backend/pkg/usecase/interfaces"
        "github.com/shion0625/FYP/backend/pkg/utils"
)

type productUseCase struct {
        productRepo  interfaces.ProductRepository
        cloudService cloud.CloudService
}

// to get a new instance of productUseCase.
func NewProductUseCase(productRepo interfaces.ProductRepository, cloudService cloud.CloudService) usecaseInterfaces.ProductUseCase <span class="cov8" title="1">{
        return &amp;productUseCase{
                productRepo:  productRepo,
                cloudService: cloudService,
        }
}</span>

const numGoroutines = 2

func (p *productUseCase) FindAllCategories(ctx echo.Context, pagination request.Pagination) ([]response.Category, error) <span class="cov8" title="1">{
        categories, err := p.productRepo.FindAllMainCategories(ctx, pagination)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed find all main categories: %w", err)
        }</span>

        <span class="cov8" title="1">return categories, nil</span>
}

// Save category.
func (p *productUseCase) SaveCategory(ctx echo.Context, categoryName string) error <span class="cov8" title="1">{
        categoryExist, err := p.productRepo.IsCategoryNameExist(ctx, categoryName)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to check category already exist: %w", err)
        }</span>

        <span class="cov8" title="1">if categoryExist </span><span class="cov8" title="1">{
                return ErrCategoryAlreadyExist
        }</span>

        <span class="cov8" title="1">err = p.productRepo.SaveCategory(ctx, categoryName)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to save category: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// to add new variation for a category.
func (p *productUseCase) SaveVariation(ctx echo.Context, categoryID uint, variationNames []string) error <span class="cov8" title="1">{
        err := p.productRepo.Transactions(ctx, func(repo interfaces.ProductRepository) error </span><span class="cov8" title="1">{
                for _, variationName := range variationNames </span><span class="cov8" title="1">{
                        variationExist, err := repo.IsVariationNameExistForCategory(ctx, variationName, categoryID)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to check variation already exist: %w", err)
                        }</span>

                        <span class="cov8" title="1">if variationExist </span><span class="cov8" title="1">{
                                return fmt.Errorf("variation name %s: %w", variationName, ErrVariationAlreadyExist)
                        }</span>

                        <span class="cov8" title="1">err = p.productRepo.SaveVariation(ctx, categoryID, variationName)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to save variation: %w", err)
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to save variation: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// to add new variation value for variation.
func (p *productUseCase) SaveVariationOption(ctx echo.Context, variationID uint, variationOptionValues []string) error <span class="cov8" title="1">{
        err := p.productRepo.Transactions(ctx, func(repo interfaces.ProductRepository) error </span><span class="cov8" title="1">{
                for _, variationValue := range variationOptionValues </span><span class="cov8" title="1">{
                        valueExist, err := repo.IsVariationValueExistForVariation(ctx, variationValue, variationID)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to check variation already exist: %w", err)
                        }</span>
                        <span class="cov8" title="1">if valueExist </span><span class="cov8" title="1">{
                                return fmt.Errorf("variation option value %s: %w", variationValue, ErrVariationOptionAlreadyExist)
                        }</span>

                        <span class="cov8" title="1">err = repo.SaveVariationOption(ctx, variationID, variationValue)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to save variation option: %w", err)
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to save variation option: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (p *productUseCase) FindAllVariationsAndItsValues(ctx echo.Context, categoryID uint) ([]response.Variation, error) <span class="cov8" title="1">{
        variations, err := p.productRepo.FindAllVariationsByCategoryID(ctx, categoryID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to find all variations of category: %w", err)
        }</span>

        // get all variation values of each variations
        <span class="cov8" title="1">for i, variation := range variations </span><span class="cov8" title="1">{
                variationOption, err := p.productRepo.FindAllVariationOptionsByVariationID(ctx, variation.ID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to get variation option: %w", err)
                }</span>

                <span class="cov8" title="1">variations[i].VariationOptions = variationOption</span>
        }

        <span class="cov8" title="1">return variations, nil</span>
}

// to get all product.
func (p *productUseCase) FindAllProducts(ctx echo.Context, pagination request.Pagination, categoryID *uint, brandID *uint) ([]response.Product, error) <span class="cov8" title="1">{
        products, err := p.productRepo.FindAllProducts(ctx, pagination, categoryID, brandID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get product details from database: %w", err)
        }</span>

        <span class="cov8" title="1">for i := range products </span><span class="cov8" title="1">{
                url, err := p.cloudService.GetFileUrl(ctx, products[i].Image)
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">products[i].Image = url</span>
        }

        <span class="cov8" title="1">return products, nil</span>
}

func (p *productUseCase) GetProduct(ctx echo.Context, productID uint) (response.Product, error) <span class="cov8" title="1">{
        product, err := p.productRepo.FindProductByID(ctx, productID)
        if err != nil </span><span class="cov8" title="1">{
                return response.Product{}, fmt.Errorf("failed to get product from database: %w", err)
        }</span>

        <span class="cov8" title="1">url, err := p.cloudService.GetFileUrl(ctx, product.Image)
        if err != nil </span><span class="cov8" title="1">{
                return response.Product{}, fmt.Errorf("failed to get image url from could service: %w", err)
        }</span>

        <span class="cov8" title="1">product.Image = url

        return product, nil</span>
}

// to add new product.
func (p *productUseCase) SaveProduct(ctx echo.Context, product request.Product) error <span class="cov8" title="1">{
        productNameExist, err := p.productRepo.IsProductNameExist(ctx, product.Name)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to check product name already exist: %w", err)
        }</span>

        <span class="cov8" title="1">if productNameExist </span><span class="cov8" title="1">{
                return fmt.Errorf("product name %s: %w", product.Name, ErrProductAlreadyExist)
        }</span>

        <span class="cov8" title="1">uploadID, err := p.cloudService.SaveFile(ctx, product.ImageFileHeader)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to save image on cloud storage: %w", err)
        }</span>

        <span class="cov8" title="1">err = p.productRepo.SaveProduct(ctx, domain.Product{
                Name:        product.Name,
                Description: product.Description,
                CategoryID:  product.CategoryID,
                BrandID:     product.BrandID,
                Price:       product.Price,
                Image:       uploadID,
        })
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to save product: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// for add new productItem for a specific product.
func (p *productUseCase) SaveProductItem(ctx echo.Context, productID uint, productItem request.ProductItem) error <span class="cov8" title="1">{
        variationCount, err := p.productRepo.FindVariationCountForProduct(ctx, productID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get variation count of product from database: %w", err)
        }</span>

        <span class="cov8" title="1">if len(productItem.VariationOptionIDs) != int(variationCount) </span><span class="cov8" title="1">{
                return ErrNotEnoughVariations
        }</span>

        // check the given all combination already exist (Color:Red with Size:M)
        <span class="cov8" title="1">productItemExist, err := p.isProductVariationCombinationExist(productID, productItem.VariationOptionIDs)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if productItemExist </span><span class="cov8" title="1">{
                return ErrProductItemAlreadyExist
        }</span>

        <span class="cov8" title="1">err = p.productRepo.Transactions(ctx, func(trxRepo interfaces.ProductRepository) error </span><span class="cov8" title="1">{
                sku, err := utils.GenerateSKU()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate SKU: %w", err)
                }</span>

                <span class="cov8" title="1">newProductItem := domain.ProductItem{
                        ProductID:  productID,
                        QtyInStock: productItem.QtyInStock,
                        Price:      productItem.Price,
                        SKU:        sku,
                }

                productItemID, err := trxRepo.SaveProductItem(ctx, newProductItem)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save product item: %w", err)
                }</span>

                <span class="cov8" title="1">errChan := make(chan error, numGoroutines)

                newCtx, cancel := context.WithCancel(ctx.Request().Context()) // for any of one of goroutine get error then cancel the working of other also
                defer cancel()

                go func() </span><span class="cov8" title="1">{
                        // save all product configurations based on given variation option id
                        for _, variationOptionID := range productItem.VariationOptionIDs </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-newCtx.Done():<span class="cov0" title="0">
                                        return</span>
                                default:<span class="cov8" title="1">
                                        err = trxRepo.SaveProductConfiguration(ctx, productItemID, variationOptionID)
                                        if err != nil </span><span class="cov0" title="0">{
                                                errChan &lt;- fmt.Errorf("failed to save product_item configuration: %w", err)

                                                return
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">errChan &lt;- nil</span>
                }()

                <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                        // save all images for the given product item
                        for _, imageFile := range productItem.ImageFileHeaders </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-newCtx.Done():<span class="cov0" title="0">
                                        return</span>
                                default:<span class="cov8" title="1">
                                        // upload image on cloud
                                        uploadID, err := p.cloudService.SaveFile(ctx, imageFile)
                                        if err != nil </span><span class="cov0" title="0">{
                                                errChan &lt;- fmt.Errorf("failed to upload image to cloud: %w", err)

                                                return
                                        }</span>
                                        // save upload id on database
                                        <span class="cov8" title="1">err = trxRepo.SaveProductItemImage(ctx, productItemID, uploadID)
                                        if err != nil </span><span class="cov0" title="0">{
                                                errChan &lt;- fmt.Errorf("failed to save image for product item on database: %w", err)

                                                return
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">errChan &lt;- nil</span>
                }()

                // wait for the both go routine to complete
                <span class="cov8" title="1">for i := 1; i &lt;= 2; i++ </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Request().Context().Done():<span class="cov0" title="0">
                                return nil</span>
                        case err := &lt;-errChan:<span class="cov8" title="1">
                                if err != nil </span><span class="cov0" title="0">{ // if any of the goroutine send error then return the error
                                        return err
                                }</span>
                                // no error then continue for the next check of select
                        }
                }

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save product item: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (p *productUseCase) isProductVariationCombinationExist(productID uint, variationOptionIDs []uint) (exist bool, err error) <span class="cov8" title="1">{
        setOfIds := map[uint]int{}

        for _, variationOptionID := range variationOptionIDs </span><span class="cov8" title="1">{
                productItemIds, err := p.productRepo.FindAllProductItemIDsByProductIDAndVariationOptionID(context.TODO(),
                        productID, variationOptionID)

                if err != nil </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("failed to find product item ids from database using product id and variation option id: %w", err)
                }</span>

                <span class="cov8" title="1">if len(productItemIds) == 0 </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

                <span class="cov8" title="1">for _, productItemID := range productItemIds </span><span class="cov8" title="1">{
                        setOfIds[productItemID]++
                        // if any of the ids count is equal to array length it means product item id of this is the existing product item of this configuration
                        if setOfIds[productItemID] &gt;= len(variationOptionIDs) </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return false, nil</span>
}

// for get all productItem for a specific product.
func (p *productUseCase) FindAllProductItems(ctx echo.Context, productID uint) ([]response.ProductItems, error) <span class="cov8" title="1">{
        productItems, err := p.productRepo.FindAllProductItems(ctx, productID)
        completeProductItems := make([]response.ProductItems, len(productItems))

        for i, item := range productItems </span><span class="cov8" title="1">{
                completeProductItems[i] = response.ProductItems{
                        ID:               item.ID,
                        Name:             item.Name,
                        ItemName:         item.ItemName,
                        Price:            item.Price,
                        DiscountPrice:    item.DiscountPrice,
                        SKU:              item.SKU,
                        QtyInStock:       item.QtyInStock,
                        CategoryName:     item.CategoryName,
                        MainCategoryName: item.MainCategoryName,
                        BrandID:          item.BrandID,
                        BrandName:        item.BrandName,
                        Images:           item.Images,
                        VariationValues:  []response.ProductVariationValue{},
                }
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return completeProductItems, fmt.Errorf("failed to find all product items: %w", err)
        }</span>

        <span class="cov8" title="1">errChan := make(chan error, numGoroutines)
        newCtx, cancel := context.WithCancel(ctx.Request().Context())

        defer cancel()

        go func() </span><span class="cov8" title="1">{
                // get all variation values of each product items
                for i := range completeProductItems </span><span class="cov8" title="1">{
                        select </span>{ // checking each time echo is cancelled or not
                        case &lt;-ctx.Request().Context().Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov8" title="1">
                                variationValues, err := p.productRepo.FindAllVariationValuesOfProductItem(ctx, completeProductItems[i].ID)
                                if err != nil </span><span class="cov8" title="1">{
                                        errChan &lt;- fmt.Errorf("failed to find variation values product item: %w", err)

                                        return
                                }</span>

                                <span class="cov8" title="1">completeProductItems[i].VariationValues = variationValues</span>
                        }
                }
                <span class="cov8" title="1">errChan &lt;- nil</span>
        }()

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                // get all images of each product items
                for i := range completeProductItems </span><span class="cov8" title="1">{
                        select </span>{ // checking each time echo is cancelled or not
                        case &lt;-newCtx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov8" title="1">
                                images, err := p.productRepo.FindAllProductItemImages(ctx, completeProductItems[i].ID)

                                imageUrls := make([]string, len(images))

                                for j := range images </span><span class="cov8" title="1">{
                                        url, err := p.cloudService.GetFileUrl(ctx, images[j])
                                        if err != nil </span><span class="cov8" title="1">{
                                                errChan &lt;- fmt.Errorf("failed to get image url from could service: %w", err)
                                        }</span>

                                        <span class="cov8" title="1">imageUrls[j] = url</span>
                                }

                                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                        errChan &lt;- fmt.Errorf("failed to find images of product item: %w", err)

                                        return
                                }</span>

                                <span class="cov8" title="1">completeProductItems[i].Images = imageUrls</span>
                        }
                }
                <span class="cov8" title="1">errChan &lt;- nil</span>
        }()

        // wait for the two routine to complete
        <span class="cov8" title="1">for i := 1; i &lt;= 2; i++ </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Request().Context().Done():<span class="cov0" title="0">
                        return nil, nil</span>
                case err := &lt;-errChan:<span class="cov8" title="1">
                        // no error then continue for the next check
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return completeProductItems, nil</span>
}

func (p *productUseCase) UpdateProduct(ctx echo.Context, updateDetails domain.Product) error <span class="cov8" title="1">{
        nameExistForOther, err := p.productRepo.IsProductNameExistForOtherProduct(ctx, updateDetails.Name, updateDetails.ID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to check product name already exist for other product: %w", err)
        }</span>

        <span class="cov8" title="1">if nameExistForOther </span><span class="cov8" title="1">{
                return fmt.Errorf("product name %s: %w", updateDetails.Name, ErrProductAlreadyExist)
        }</span>

        // p.productRepo.FindProductByID(ctx, updateDetails.ID)

        <span class="cov8" title="1">err = p.productRepo.UpdateProduct(ctx, updateDetails)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to update product: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package usecase

import (
        "errors"
        "fmt"
        "log"

        "github.com/jinzhu/copier"
        "github.com/labstack/echo/v4"
        "github.com/shion0625/FYP/backend/pkg/api/handler/request"
        "github.com/shion0625/FYP/backend/pkg/api/handler/response"
        "github.com/shion0625/FYP/backend/pkg/config"
        "github.com/shion0625/FYP/backend/pkg/domain"
        "github.com/shion0625/FYP/backend/pkg/repository/interfaces"
        service "github.com/shion0625/FYP/backend/pkg/usecase/interfaces"
        "github.com/shion0625/FYP/backend/pkg/utils"
        "golang.org/x/crypto/bcrypt"
)

const (
        bcryptCost            = 10
        MinCreditNumberLength = 4
)

type userUserCase struct {
        userRepo      interfaces.UserRepository
        creditCardKey string
}

func NewUserUseCase(cfg *config.Config, userRepo interfaces.UserRepository) service.UserUseCase <span class="cov0" title="0">{
        return &amp;userUserCase{
                userRepo:      userRepo,
                creditCardKey: cfg.CreditCardKey,
        }
}</span>

func (u *userUserCase) FindProfile(ctx echo.Context, userID string) (domain.User, error) <span class="cov0" title="0">{
        user, err := u.userRepo.FindUserByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return domain.User{}, fmt.Errorf("failed to find user details: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (u *userUserCase) UpdateProfile(ctx echo.Context, user domain.User) error <span class="cov0" title="0">{
        // first check any other user exist with this entered unique fields
        checkUser, err := u.userRepo.FindUserByUserNameEmailOrPhone(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find user: %w", err)
        }</span>

        <span class="cov0" title="0">if checkUser.ID != "" </span><span class="cov0" title="0">{ // if there is an user exist with given details then make it as error
                if err := utils.CompareUserExistingDetails(user, checkUser); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to compare user details: %w", err)
                }</span>
        }

        // if user password given then hash the password
        <span class="cov0" title="0">if user.Password != "" </span><span class="cov0" title="0">{
                hash, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcryptCost)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate hash password for user: %w", err)
                }</span>

                <span class="cov0" title="0">user.Password = string(hash)</span>
        }

        <span class="cov0" title="0">err = u.userRepo.UpdateUser(ctx, user)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// adddress.
func (u *userUserCase) SaveAddress(ctx echo.Context, userID string, address domain.Address, isDefault bool) error <span class="cov0" title="0">{
        exist, err := u.userRepo.IsAddressAlreadyExistForUser(ctx, address, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check address already exist \nerror:%v", err.Error())
        }</span>

        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                return fmt.Errorf("given address already exist for user")
        }</span>

        // save the address on database
        <span class="cov0" title="0">addressID, err := u.userRepo.SaveAddress(ctx, address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save address: %w", err)
        }</span>

        <span class="cov0" title="0">userAddress := domain.UserAddress{
                UserID:    userID,
                AddressID: addressID,
                IsDefault: isDefault,
        }

        // then update the address with user
        err = u.userRepo.SaveUserAddress(ctx, userAddress)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save user address: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (u *userUserCase) UpdateAddress(ctx echo.Context, addressBody request.EditAddress, userID string) error <span class="cov0" title="0">{
        if exist, err := u.userRepo.IsAddressIDExist(ctx, addressBody.ID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check address ID existence: %w", err)
        }</span> else<span class="cov0" title="0"> if !exist </span><span class="cov0" title="0">{
                return errors.New("invalid address id")
        }</span>

        <span class="cov0" title="0">var address domain.Address
        if err := copier.Copy(&amp;address, &amp;addressBody); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy address: %w", err)
        }</span>

        <span class="cov0" title="0">if err := u.userRepo.UpdateAddress(ctx, address); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update address: %w", err)
        }</span>

        // check the user address need to set default or not if it need then set it as default
        <span class="cov0" title="0">if addressBody.IsDefault != nil &amp;&amp; *addressBody.IsDefault </span><span class="cov0" title="0">{
                userAddress := domain.UserAddress{
                        UserID:    userID,
                        AddressID: address.ID,
                        IsDefault: *addressBody.IsDefault,
                }

                err := u.userRepo.UpdateUserAddress(ctx, userAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update user address: %w", err)
                }</span>
        }

        <span class="cov0" title="0">log.Printf("successfully address saved for user with user_id %s", userID)

        return nil</span>
}

// get all address.
func (u *userUserCase) FindAddresses(ctx echo.Context, userID string) (addresses []response.Address, err error) <span class="cov0" title="0">{
        addresses, err = u.userRepo.FindAllAddressByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find addresses: %w", err)
        }</span>

        <span class="cov0" title="0">return addresses, nil</span>
}

func (u *userUserCase) FindAddress(ctx echo.Context, userID string, addressID uint) (domain.Address, error) <span class="cov0" title="0">{
        user, err := u.userRepo.FindAddressByUserIDAndAddressID(ctx, userID, addressID)
        if err != nil </span><span class="cov0" title="0">{
                return domain.Address{}, fmt.Errorf("failed to find user details: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (u *userUserCase) FindPaymentMethods(ctx echo.Context, userID string) (paymentMethods []response.PaymentMethod, err error) <span class="cov0" title="0">{
        paymentMethods, err = u.userRepo.FindAllPaymentMethodsByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find payment method: %w", err)
        }</span>

        <span class="cov0" title="0">for i, method := range paymentMethods </span><span class="cov0" title="0">{
                creditNumberDecrypted := utils.Decrypt(method.Number, userID+u.creditCardKey)
                if len(creditNumberDecrypted) &gt;= MinCreditNumberLength </span><span class="cov0" title="0">{
                        paymentMethods[i].Number = creditNumberDecrypted[len(creditNumberDecrypted)-4:]
                }</span>
        }

        <span class="cov0" title="0">return paymentMethods, nil</span>
}

// to add new product.
func (u *userUserCase) SavePaymentMethod(ctx echo.Context, userID string, paymentMethod request.PaymentMethod) error <span class="cov0" title="0">{
        _, err := u.userRepo.SavePaymentMethod(ctx, domain.PaymentMethod{
                Number:      utils.Encrypt(paymentMethod.Number, userID+u.creditCardKey),
                Expiry:      paymentMethod.Expiry,
                Cvc:         paymentMethod.Cvc,
                UserId:      userID,
                CardCompany: utils.GetCardIssuer(paymentMethod.Number),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save product: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package utils

import (
        "errors"

        "github.com/shion0625/FYP/backend/pkg/domain"
)

// To compare and return error for the same fields.
func CompareUserExistingDetails(user1, user2 domain.User) error <span class="cov8" title="1">{
        var err error
        if user1.Email == user2.Email </span><span class="cov8" title="1">{
                err = AppendMessageToError(err, "user already exists with this email")
        }</span>

        <span class="cov8" title="1">if user1.UserName == user2.UserName </span><span class="cov8" title="1">{
                err = AppendMessageToError(err, "user already exists with this username")
        }</span>

        <span class="cov8" title="1">if user1.Phone == user2.Phone </span><span class="cov8" title="1">{
                err = AppendMessageToError(err, "user already exists with this phone number")
        }</span>

        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                return errors.New("failed to find existing details")
        }</span>

        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package utils

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/hex"
        "io"
        "strings"
)

func Encrypt(stringToEncrypt string, keyString string) (encryptedString string) <span class="cov8" title="1">{
        key, _ := hex.DecodeString(keyString)
        plaintext := []byte(stringToEncrypt)
        key = key[:32]

        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov8" title="1">aesGCM, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov8" title="1">nonce := make([]byte, aesGCM.NonceSize())
        if _, err = io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov8" title="1">ciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)

        return hex.EncodeToString(ciphertext)</span>
}

func Decrypt(encryptedString string, keyString string) (decryptedString string) <span class="cov8" title="1">{
        enc, _ := hex.DecodeString(encryptedString)
        key, _ := hex.DecodeString(keyString)
        key = key[:32]

        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov8" title="1">aesGCM, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov8" title="1">nonceSize := aesGCM.NonceSize()
        nonce, ciphertext := enc[:nonceSize], enc[nonceSize:]

        plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov8" title="1">return string(plaintext)</span>
}

func GetCardIssuer(cardNumber string) string <span class="cov8" title="1">{
        switch </span>{
        case strings.HasPrefix(cardNumber, "4"):<span class="cov8" title="1">
                return "Visa"</span>
        case strings.HasPrefix(cardNumber, "5"):<span class="cov8" title="1">
                return "MasterCard"</span>
        case strings.HasPrefix(cardNumber, "34") || strings.HasPrefix(cardNumber, "37"):<span class="cov8" title="1">
                return "American Express"</span>
        case strings.HasPrefix(cardNumber, "6"):<span class="cov8" title="1">
                return "Discover"</span>
        case strings.HasPrefix(cardNumber, "36"):<span class="cov8" title="1">
                return "Diners Club"</span>
        default:<span class="cov8" title="1">
                return "Unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package utils

import (
        "errors"
        "fmt"
)

// To append the message to the error.
func AppendMessageToError(err error, message string) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return errors.New(message)
        }</span>

        <span class="cov8" title="1">return fmt.Errorf("%w \n%s", err, message)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package utils

import (
        "errors"

        "github.com/labstack/echo/v4"
)

var ErrInvalidParam = errors.New("invalid parameter")

// To append the message to the error.
func GetParamID(ctx echo.Context, key string) (*uint, error) <span class="cov8" title="1">{
        IDStr := ctx.QueryParam(key)

        if IDStr == "" </span><span class="cov8" title="1">{
                //nolint:nilnil
                return nil, nil
        }</span>

        <span class="cov8" title="1">ID, err := ParseStringToUint32(IDStr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidParam
        }</span>

        <span class="cov8" title="1">return &amp;ID, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package utils

import (
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "strconv"

        "github.com/google/uuid"
        "github.com/labstack/echo/v4"
        "golang.org/x/crypto/bcrypt"
)

var (
        suffixLength     = 4
        numbersLength    = 10
        couponCodeLength = 30
        skuLength        = 10
        bcryptCost       = 10
)

// take userId from context.
func GetUserIdFromContext(ctx echo.Context) (string, error) <span class="cov8" title="1">{
        userID, ok := ctx.Get("userId").(string)
        if !ok </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to get userID from context")
        }</span>

        <span class="cov8" title="1">return userID, nil</span>
}

func ParseStringToUint32(param string) (uint, error) <span class="cov8" title="1">{
        value, err := strconv.ParseUint(param, 10, 32)

        return uint(value), err
}</span>

// generate unique string for sku.
func GenerateSKU() (string, error) <span class="cov8" title="1">{
        sku := make([]byte, skuLength)

        _, err := rand.Read(sku)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to generate SKU: %w", err)
        }</span>

        <span class="cov8" title="1">return hex.EncodeToString(sku), nil</span>
}

func ComparePasswordWithHashedPassword(actualPassword, hashedPassword string) error <span class="cov8" title="1">{
        if err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(actualPassword)); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to compare password with hashed password: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func GenerateUniqueString() string <span class="cov8" title="1">{
        return uuid.NewString()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package utils

import "golang.org/x/crypto/bcrypt"

func GenerateHashFromPassword(password string) (string, error) <span class="cov8" title="1">{
        hash, err := bcrypt.GenerateFromPassword([]byte(password), bcryptCost)

        return string(hash), err
}</span>

func VerifyHashAndPassword(hashedPassword, password string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))

        return err == nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
